;; Forth implementation based on jonesforth for Notch's dcpu

;; special reguisters:
;; i source
;; z return stack pointer

#defmacro NEXT() {		//jump to the address stored at the location pointed to by i
        var r = "";
	r += "set a, [i]\n";
	r += "add i, 1\n";
	r += "set PC, a\n";
	return r;
}

#defmacro PUSHRSP(reg) {
	var r = "";
	r += "sub z, 1\n";
	r += "set [z]," + reg + "\n";
	return r;
}

#defmacro POPRSP(reg) {
	var r = "";
	r += "set " + reg + ", [z]\n";
	r += "add z, 1\n";
	return r;
}

set pc, start

:DOCOL
	PUSHRSP("i")		;push i on to the return stack
	add a,1			;a points to the codeword
	set i,a			;now i points to the first data word
	NEXT()

:start
	set [var_S0], SP	;save the initial data stack pointer
	set z, rsp		;set initial return stack
	set i, coldstart
	NEXT()			;go!
	
:coldstart
	dat QUIT


#defmacro defword (name flags label iscode) {
        var r = "";
	r += ":name_" + label + "\n";
	r += "dat " + link + "\n";
	link = "name_"+label;
	r += "dat " + (flags + name.length) + "\n";
	r += "dat \"" + name + "\"\n";
	r += ":" + label + "\n";
	if (!iscode) {
	   r += "dat DOCOL\n";
	    } 
	else {
	   r += "dat code_" + label + "\n";
	   r += ":code_" + label + "\n";
	}
	return r;
} [var link = "0";]

	defword("DROP",0,"DROP", true)
	set a, pop		;drop top of stack
	NEXT()

	defword("SWAP",0,"SWAP", true)
	set a, pop		;drop top of stack
	set b, pop		;and the next value too
	set push, a			;now the first is the second
	set push, b			;and the second is first
	NEXT()

	defword ("DUP",0,"DUP", true)
	set a, peek		;duplicate top of stack
	set push, a

	defword ("OVER",0,"OVER", true)
	set a, sp
	add a, 1
	set a, [a]		;copy the second element of the stack
	set push, a			;on top
	NEXT()

	defword ("ROT",0,"ROT", true)
	set a, pop 
	set b, pop 
	set c, pop 
	set push, b 
	set push, a 
	set push, c 
	NEXT()

	defword ("-ROT",0,"NROT", true)
	set a, pop 
	set b, pop 
	set c, pop 
	set push, a 
	set push, c 
	set push, b 
	NEXT()

	defword ("2DROP",0,"TWODROP", true)
	set a, pop 
	set a, pop 
	NEXT()

	defword ("2DUP",0,"TWODUP", true)
	set a, peek
	set b, sp
	add b, 1
	set b,[b]
	set push, b
	set push, a
	NEXT()

	defword ("2SWAP",0,"TWOSWAP", true)
	set a, pop 
	set b, pop 
	set c, pop 
	set x, pop 
	set push, b
	set push, a
	set push, x
	set push, c
	NEXT()

	defword ("?DUP",0,"QDUP", true)
	set a, peek
	ifn a, 0
	set push, a
	NEXT()

	defword ("1+",0,"INCR", true)
	add peek,1
	NEXT()

	defword ("1-",0,"DECR", true)
	sub peek,1
	NEXT()

	defword ("2+",0,"INCR2", true)
	add peek,2
	NEXT()

	defword ("2-",0,"DECR2", true)
	sub peek,2
	NEXT()

	defword ("+",0,"ADD", true)
	set a, pop
	add peek, a
	NEXT()
	
	defword ("-",0,"SUB", true)
	set a, pop
	sub peek, a
	NEXT()
	
	defword ("*",0,"MUL", true)
	set a, pop 
	set b, pop 
	mul a, b
	set push, a
	NEXT()

	;; TODO comparisons and bitwise stuff

	defword ("EXIT",0,"EXIT", true)
	POPRSP(i)
	NEXT()

	defword ("LIT",0,"LIT", true)
	set a,[i]
	add [i], 1
	set push, a
	NEXT()

	;; TODO memory management stuff

#defmacro defvar(name flags label initial) {
	r = macros["defword"](name,flags,label, true);
	r += "set push, var_" + name + "\n";
	r += macros["NEXT"]();
	r += ":var_" + name + "\n";
	r += "dat " + initial + "\n";
	return r;
}

	defvar ("STATE",0,"STATE",0)
	defvar ("HERE",0,"HERE",0)
	defvar ("LATEST",0,"LATEST","SYSCALL0") ;this must be the last word
	defvar ("S0",0,"SZ",0)
	defvar ("BASE",0,"BASE",10)

	;; TODO built in constants

:rsp
	dat 0
